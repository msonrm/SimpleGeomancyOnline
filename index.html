<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ジオマンシー ワンオラクル</title>
    <meta name="description" content="シンプルなジオマンシー占いアプリ - ワンオラクルでメッセージを受け取ろう">
    <meta name="theme-color" content="#e8dcc6">
    
    <!-- PWA manifest -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8LXKHGRD8W"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-8LXKHGRD8W');
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #e8dcc6 0%, #d4c4a8 100%);
            min-height: 100vh;
            color: #5d4e37;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .oracle-screen .container {
            padding: 20px;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            margin-top: 20px;
        }

        .title {
            font-size: 28px;
            font-weight: 300;
            color: #5d4e37;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .subtitle {
            font-size: 16px;
            color: rgba(93,78,55,0.8);
            font-weight: 300;
        }

        .oracle-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 30px 0;
        }

        .oracle-button {
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 24px;
            border-radius: 16px;
            font-size: 18px;
            font-weight: 500;
            color: #5d4e37;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .oracle-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }

        .oracle-button:active {
            transform: translateY(0);
        }

        .info-section {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .app-promo-section {
            margin-top: auto;
        }

        .info-title {
            font-size: 18px;
            font-weight: 600;
            color: #5d4e37;
            margin-bottom: 12px;
        }

        .info-text {
            font-size: 14px;
            color: rgba(93,78,55,0.8);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .info-text a {
            color: #8b7355;
            text-decoration: underline;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .info-text a:hover {
            color: #5d4e37;
        }

        .info-text .shield-chart-link {
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: underline;
        }

        .info-text .shield-chart-link:hover {
            color: #8b7355;
        }

        .shield-chart-preview {
            float: right;
            width: 120px;
            margin: 0 0 12px 16px;
            opacity: 0.85;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .shield-chart-preview:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        @media (max-width: 480px) {
            .shield-chart-preview {
                width: 100px;
                margin: 0 0 8px 12px;
            }
        }

        .info-link {
            display: inline-block;
            color: #8b7355;
            text-decoration: underline;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .info-link:hover {
            color: #5d4e37;
        }

        .copyright {
            text-align: center;
            padding: 20px;
            color: rgba(93,78,55,0.6);
            font-size: 12px;
        }

        .copyright a {
            color: rgba(93,78,55,0.7);
            text-decoration: none;
            transition: all 0.2s ease;
        }

        .copyright a:hover {
            color: #5d4e37;
            text-decoration: underline;
        }

        .app-links-container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .app-link {
            display: inline-block;
            background: #8b7355;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139,115,85,0.3);
            text-align: center;
            flex: 1;
        }

        .app-link:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(139,115,85,0.4);
        }

        .update-banner {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #5d4e37;
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            z-index: 1001;
            text-align: center;
            max-width: 90%;
            min-width: 320px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .update-banner.show {
            display: block;
            opacity: 1;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .update-button {
            background: white;
            color: #5d4e37;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-left: 12px;
            transition: all 0.2s ease;
        }

        .update-button:hover {
            transform: scale(1.05);
            background: #f5f0e8;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        .back-button {
            background: none;
            border: none;
            color: #5d4e37;
            padding: 16px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: block;
            text-align: left;
        }

        .back-button:hover {
            color: #8b7355;
        }

        .oracle-screen {
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .oracle-title {
            font-size: 24px;
            color: #5d4e37;
            margin-bottom: 30px;
            font-weight: 300;
        }

        .dot-zones {
            display: flex;
            flex-direction: column;
            width: 100%;
            margin: 0;
            border: none;
            border-radius: 0;
            overflow: hidden;
            flex: 1;
        }

        .dot-zone {
            background: rgba(255,255,255,0.6);
            border-bottom: 1px solid rgba(93,78,55,0.3);
            min-height: 100px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 100%;
        }

        .dot-zone:last-child {
            border-bottom: none;
        }

        .dots-display {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 100px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #8b7355;
            border-radius: 50%;
            position: absolute;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .zone-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .generate-button {
            background: rgba(93,78,55,0.3);
            border: none;
            color: #5d4e37;
            padding: 16px 32px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: not-allowed;
            margin: 20px auto;
            transition: all 0.3s ease;
            opacity: 0.5;
        }

        .generate-button.active {
            background: #8b7355;
            color: white;
            cursor: pointer;
            opacity: 1;
        }

        .generate-button.active:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139,115,85,0.3);
        }

        .roll-button {
            background: #8b7355;
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .roll-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139,115,85,0.3);
        }

        .roll-button:disabled {
            background: rgba(139,115,85,0.3);
            cursor: not-allowed;
            transform: none;
        }

        .dice-results {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .dice-result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dice-result-box {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 12px;
            width: 60px;
            height: 60px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dice-result-box.fire {
            border-color: #ffaaaa;
            background: #ffdddd;
        }

        .dice-result-box.air {
            border-color: #ffffaa;
            background: #ffffdd;
        }

        .dice-result-box.water {
            border-color: #aaccff;
            background: #ddeeff;
        }

        .dice-result-box.earth {
            border-color: #aaffaa;
            background: #ddffdd;
        }

        .element-label {
            font-size: 11px;
            color: rgba(93,78,55,0.8);
            font-weight: 600;
        }

        .dice-value {
            font-size: 20px;
            font-weight: bold;
            color: #5d4e37;
        }

        .dice-value.empty {
            color: rgba(93,78,55,0.3);
            font-size: 16px;
        }

        .symbol-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .symbol-dialog.show {
            opacity: 1;
            visibility: visible;
        }

        .symbol-content {
            background: #f5f0e8;
            border: 2px solid #8b7355;
            border-radius: 12px;
            width: calc(100% - 40px);
            max-width: 400px;
            position: relative;
            padding: 24px;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .symbol-dialog.show .symbol-content {
            opacity: 1;
            transform: scale(1);
        }

        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .symbol-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #5d4e37;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: #8b7355;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-button:hover {
            background: rgba(139,115,85,0.1);
            color: #5d4e37;
        }

        .symbol-image-area {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 8px;
            border: 1px solid rgba(139,115,85,0.2);
        }

        .symbol-image {
            max-width: 100%;
            height: auto;
            max-height: 200px;
        }

        .symbol-name {
            font-size: 18px;
            font-weight: 600;
            color: #5d4e37;
            text-align: center;
            margin-bottom: 16px;
        }

        .symbol-attributes {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .symbol-attribute {
            background: rgba(139,115,85,0.1);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            color: #5d4e37;
            font-weight: 500;
        }

        .symbol-meaning {
            font-size: 15px;
            color: #5d4e37;
            line-height: 1.6;
            text-align: left;
        }

        .symbol-expand-section {
            margin-top: 20px;
            border-top: 1px solid rgba(139,115,85,0.2);
            padding-top: 16px;
            text-align: right;
        }

        .symbol-expand-toggle {
            display: inline-flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 6px 12px;
            color: rgba(139,115,85,0.8);
            font-size: 13px;
            font-weight: 400;
            transition: all 0.2s ease;
            border-radius: 6px;
            background: rgba(139,115,85,0.05);
            gap: 8px;
            min-width: 100px;
        }

        .symbol-expand-toggle:hover {
            color: #8b7355;
            background: rgba(139,115,85,0.1);
        }

        .symbol-expand-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            text-align: left;
        }

        .symbol-expand-content.open {
            max-height: 200px;
        }

        .symbol-expand-text {
            padding-top: 12px;
            font-size: 13px;
            color: rgba(93,78,55,0.8);
            line-height: 1.5;
        }

        .symbol-expand-text a {
            color: #8b7355;
            text-decoration: underline;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .symbol-expand-text a:hover {
            color: #5d4e37;
        }

        #expand-arrow {
            transition: transform 0.3s ease;
        }

        #expand-arrow.rotated {
            transform: rotate(180deg);
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .oracle-button {
                padding: 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="home-screen" class="screen active">
            <div class="header">
                <h1 class="title">ジオマンシー ワンオラクル</h1>
            </div>

            <div class="info-section">
                <h3 class="info-title">ジオマンシーとは</h3>
                <p class="info-text">
                    古代から伝わる土占い。16のシンボルをつかいます。シンプルでありながら、具体的で明快なメッセージを受け取ることができます。
                </p>
                <a href="https://kiriya-t.com/geomancy/" class="info-link" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'external_link_click', {'link_destination': 'kiriya_report', 'event_category': 'outbound_links', 'event_label': 'kiriya_geomancy_report'});">
                    → さらに詳しく：高橋桐矢「キリヤ・レポート」
                </a>
                <p class="info-text" style="margin-top: 16px;">
                    ワンオラクルは最も基本的な占い方で、ただ一つのシンボルから答えを導き出します。このウェブアプリではワンオラクルを、伝統的なドットを打つ方法と、もっとカジュアルなダイスを振る方法とで試すことができます。
                </p>
                <p class="info-text" style="margin-top: 16px;">
                    <img src="ShieldChart.png" alt="シールドチャート例" class="shield-chart-preview" onclick="showShieldChartInfo()">
                    ジオマンシーには、ワンオラクル以外にも様々な占い方があります。特に<strong class="shield-chart-link" onclick="showShieldChartInfo()">シールドチャート</strong>はジオマンシーの奥義といわれる占法で、もっとも詳細で緻密な回答が得られます。下記のスマートフォンアプリ「Geomancy Diary」では、このシールドチャートでも占うことができます。
                </p>
            </div>

            <div class="oracle-buttons">
                <button class="oracle-button" onclick="showDotOracle()">
                    ワンオラクル（ドット）で占う
                </button>
                
                <button class="oracle-button" onclick="showDiceOracle()">
                    ワンオラクル（ダイス）で占う
                </button>
            </div>

            <div class="info-section app-promo-section">
                <h3 class="info-title">スマートフォンアプリ「Geomancy Diary」</h3>
                <p class="info-text">
                    このウェブアプリはお試し版です。より本格的なジオマンシーを楽しみたい方は、スマートフォンアプリ「Geomancy Diary」をご利用ください。各シンボルのより詳しい解説・対応や、占った記録を保存する機能、シンボル一覧から詳細を確認できる簡易学習機能などがあります。
                </p>
                <p class="info-text">
                    <strong>iPhone/iPadアプリ：</strong>児童書作家兼占い師でありジオマンシーの第一人者・<a href="https://lit.link/kiriya" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'external_link_click', {'link_destination': 'kiriya_profile', 'event_category': 'outbound_links', 'event_label': 'kiriya_lit_link'});">高橋桐矢</a>さまによるシンボル毎の詳細なメッセージ、占い師・イラストレーターの<a href="https://noristarcream.wixsite.com/noristarcream" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'external_link_click', {'link_destination': 'nori_star_cream', 'event_category': 'outbound_links', 'event_label': 'nori_star_cream_site'});">NORI STAR CREAM</a>さまの心あたたまるカラーテーマ。ドット、ダイスそれぞれでワンオラクルとシールドチャートに対応します。また、ジオマンシーカード等で占った結果も記録できます。
                </p>
                <p class="info-text">
                    <strong>Androidアプリ：</strong>ワンオラクルに加え、シールドチャート、シンプル・トリプシティ、パスワークなど多彩な占い方法に対応。本格的なジオマンシー占いを手軽に楽しめます。
                </p>
                <div class="app-links-container">
                    <a href="https://apps.apple.com/jp/app/geomancy-diary/id6670341755" class="app-link" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'app_store_click', {'platform': 'ios', 'event_category': 'app_promotion', 'event_label': 'ios_app_store_link'});">
                        iPhone/iPad<br>（App Store）
                    </a>
                    <a href="https://play.google.com/store/apps/details?id=io.kodular.msonrm.geomancy_diary" class="app-link" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'app_store_click', {'platform': 'android', 'event_category': 'app_promotion', 'event_label': 'android_play_store_link'});">
                        Android<br>（Google Play）
                    </a>
                </div>
            </div>

            <div class="info-section">
                <h3 class="info-title">このページをアプリとしてインストールできます</h3>
                <p class="info-text">
                    <strong>iPhone/iPad（Safari）:</strong><br>
                    共有ボタン（□↑）→「ホーム画面に追加」
                </p>
                <p class="info-text">
                    <strong>Android（Chrome）:</strong><br>
                    メニュー（⋮）→「ホーム画面に追加」
                </p>
                <p class="info-text">
                    <strong>PC（Chrome/Edge）:</strong><br>
                    アドレスバー右端のインストールアイコン（＋）をクリック
                </p>
            </div>

            <div class="copyright">
                © 2025 <a href="https://x.com/msonrm" target="_blank" rel="noopener noreferrer" onclick="gtag('event', 'external_link_click', {'link_destination': 'developer_twitter', 'event_category': 'outbound_links', 'event_label': 'msonrm_twitter'});">msonrm（なるなる）</a>
            </div>
        </div>

        <div id="dot-oracle-screen" class="screen">
            <button class="back-button" onclick="showHome()">← 戻る</button>
            
            <div class="dot-zones">
                <div class="dot-zone" onclick="tapZone(event, 0)" ontouchstart="handleTouch(event, 0)">
                    <div class="dots-display" id="zone-0">
                        <canvas class="zone-canvas" id="canvas-0"></canvas>
                    </div>
                </div>
                <div class="dot-zone" onclick="tapZone(event, 1)" ontouchstart="handleTouch(event, 1)">
                    <div class="dots-display" id="zone-1">
                        <canvas class="zone-canvas" id="canvas-1"></canvas>
                    </div>
                </div>
                <div class="dot-zone" onclick="tapZone(event, 2)" ontouchstart="handleTouch(event, 2)">
                    <div class="dots-display" id="zone-2">
                        <canvas class="zone-canvas" id="canvas-2"></canvas>
                    </div>
                </div>
                <div class="dot-zone" onclick="tapZone(event, 3)" ontouchstart="handleTouch(event, 3)">
                    <div class="dots-display" id="zone-3">
                        <canvas class="zone-canvas" id="canvas-3"></canvas>
                    </div>
                </div>
            </div>
            
            <div style="padding: 16px 20px 20px 20px; text-align: center;">
                <p style="color: rgba(93,78,55,0.7); font-size: 14px; margin-bottom: 16px; line-height: 1.4;">
                    どんなことを占いたいのかを強く心に思いながら、4つの領域を右から左に向かってタップしていき、思いのままにドットを打ってください。4つすべてにドットが打たれたら「シンボルを生成」ボタンを押してください。ドットの個数（偶数・奇数）に応じてジオマンシーのシンボルが決まります。
                </p>
                <button class="generate-button" id="generate-btn" onclick="generateSymbol()">
                    シンボルを生成
                </button>
            </div>
        </div>

        <div id="dice-oracle-screen" class="screen">
            <button class="back-button" onclick="showHome()">← 戻る</button>
            
            <div style="flex: 1; display: flex; flex-direction: column;">
                <div id="dice-3d-container" style="width: 100%; aspect-ratio: 1; max-width: 600px; margin: 0 auto; position: relative; background: rgba(255,255,255,0.3); border-radius: 12px;">
                </div>
                
                <div style="padding: 16px 20px 20px 20px; text-align: center;">
                    <p style="color: rgba(93,78,55,0.7); font-size: 14px; margin-bottom: 16px; line-height: 1.4;">
                        どんなことを占いたいのかを強く心に思いながら、あなたのタイミングで「ダイスを振る」ボタンを押してください。4つのエレメント（火・風・水・地）を象徴する4つのダイスが振られ、出た目に応じてジオマンシーのシンボルが決まります。
                    </p>
                    
                    <div class="dice-results">
                        <div class="dice-result-container">
                            <div class="dice-result-box fire">
                                <div class="dice-value empty" id="dice-result-0">?</div>
                            </div>
                            <div class="element-label">火</div>
                        </div>
                        <div class="dice-result-container">
                            <div class="dice-result-box air">
                                <div class="dice-value empty" id="dice-result-1">?</div>
                            </div>
                            <div class="element-label">風</div>
                        </div>
                        <div class="dice-result-container">
                            <div class="dice-result-box water">
                                <div class="dice-value empty" id="dice-result-2">?</div>
                            </div>
                            <div class="element-label">水</div>
                        </div>
                        <div class="dice-result-container">
                            <div class="dice-result-box earth">
                                <div class="dice-value empty" id="dice-result-3">?</div>
                            </div>
                            <div class="element-label">地</div>
                        </div>
                    </div>
                    
                    <button class="roll-button" id="dice-roll-btn" onclick="initDicePhysics()">ダイスを振る</button>
                </div>
            </div>
        </div>
    </div>

    <div class="update-banner" id="updateBanner">
        <span>新しいバージョンが利用可能です</span>
        <button class="update-button" onclick="updateApp()">更新</button>
        <button class="update-button" onclick="hideUpdateBanner()" style="background: transparent; color: white; margin-left: 16px;">×</button>
    </div>

    <div class="symbol-dialog" id="symbolDialog">
        <div class="symbol-content">
            <div class="symbol-header">
                <h3>ワンオラクル結果</h3>
                <button class="close-button" onclick="closeSymbolDialog()">×</button>
            </div>
            
            <div class="symbol-image-area">
                <img class="symbol-image" id="symbol-image" src="" alt="シンボル">
            </div>
            
            <div class="symbol-name" id="symbol-name">
                Fortuna Minor（小吉）
            </div>
            
            <div class="symbol-attributes">
                <div class="symbol-attribute" id="symbol-yesno">Yes/No: イエス</div>
                <div class="symbol-attribute" id="symbol-fortune">吉凶: 小吉</div>
            </div>
            
            <div class="symbol-meaning" id="symbol-meaning">
                小さく一時的な幸運、ささやかな幸せ。周りからの援助。
            </div>
            
            <div class="symbol-expand-section">
                <div class="symbol-expand-toggle" onclick="toggleSymbolDetails()">
                    <span id="expand-text">保存するには</span>
                    <span id="expand-arrow">▼</span>
                </div>
                <div class="symbol-expand-content" id="symbol-expand-content">
                    <div class="symbol-expand-text">
                       <strong>占いの記録を残すことで、自分のパターンや変化に気づけます。</strong><br>
                       スマートフォンアプリ「<a href="#" onclick="gtag('event', 'app_promotion_click', {'source': 'symbol_details', 'event_category': 'app_promotion', 'event_label': 'geomancy_diary_from_symbol'}); closeSymbolDialog(); showHome(); scrollToAppSection();">Geomancy Diary</a>」なら、「仕事の悩み」「恋愛相談」など、何を占ったのか・結果はどうだったのかを記録できます。あとで振り返って、占いの結果と実際のできごとを照らし合わせることができます。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="symbol-dialog" id="shieldChartDialog">
        <div class="symbol-content">
            <div class="symbol-header">
                <h3>シールドチャートとは</h3>
                <button class="close-button" onclick="closeShieldChartDialog()">×</button>
            </div>
            
            <div class="symbol-image-area">
                <img class="symbol-image" src="ShieldChart.png" alt="シールドチャート">
            </div>
            
            <div class="symbol-meaning">
                シールドチャートは、ジオマンシーの奥義といわれる本格的な占い方法です。<br><br>
                まず4つのシンボルが示され、そこから全部で15のシンボルを導き出します。ワンオラクルよりもずっと詳しい状況分析や、複雑な質問への回答が得られます。<br><br>
                シンボルの配置が盾（シールド）の形に見立てられることから、「シールドチャート」と呼ばれています。
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.js"></script>

    <script>
        let zoneDots = [[], [], [], []];
        let isGenerating = false;
        let scene, camera, renderer, world;
        let animationId;
        let diceObjects = [];
        let diceResults = [];
        let updateAvailable = false;
        let deferredPrompt;
        let clock = null;

        const geomancySymbols = {
            '2222': { name: 'Populus（人々）', meaning: '物事や人が多数ある状態。受け身。安定。', symbol: '••\n••\n••\n••', yesno: 'イエス', fortune: '吉' },
            '1111': { name: 'Via（道）', meaning: '変化、動くこと、過程。決断。積極性、能動性。', symbol: '•\n•\n•\n•', yesno: 'ノー', fortune: '吉でも凶でもない。旅や移動について吉' },
            '2112': { name: 'Conjunctio（つながり）', meaning: '違う者同士結びつく、目的を持って集まる、絆が生まれる。失せ物が見つかる。', symbol: '••\n•\n•\n••', yesno: 'イエス', fortune: '吉と凶の両方' },
            '1221': { name: 'Carcer（拘束）', meaning: '孤独、身動きが取れない、ひきこもり。停滞、現状維持。', symbol: '•\n••\n••\n•', yesno: 'ノー', fortune: '凶。セキュリティに関しては吉' },
            '2211': { name: 'Fortuna Major（大吉）', meaning: '大きな幸運。自分の思い通りにことが運ぶ。', symbol: '••\n••\n•\n•', yesno: 'イエス', fortune: '大吉' },
            '1122': { name: 'Fortuna Minor（小吉）', meaning: '小さく一時的な幸運、ささやかな幸せ。周りからの援助。', symbol: '•\n•\n••\n••', yesno: 'イエス', fortune: '小吉' },
            '2121': { name: 'Acquisitio（獲得）', meaning: '収穫、利益。願いが叶う。何かを受け取る、受け入れる。', symbol: '••\n•\n••\n•', yesno: 'イエス', fortune: '吉' },
            '1212': { name: 'Amissio（喪失）', meaning: '損失、愛情や金銭などを失う。病気やトラブル、悪癖がなくなる。', symbol: '•\n••\n•\n••', yesno: 'ノー', fortune: '凶' },
            '1222': { name: 'Laetitia（喜び）', meaning: '喜ばしいこと、笑い、成功。音楽や踊り。髭のある男性。', symbol: '•\n••\n••\n••', yesno: 'イエス', fortune: '吉' },
            '2221': { name: 'Tristitia（悲しみ）', meaning: '不幸、受難、宿命。', symbol: '••\n••\n••\n•', yesno: 'ノー', fortune: '凶。占いや魔術に関しては吉' },
            '1211': { name: 'Puella（少女）', meaning: '女性らしさ、美しさ。ときめき、嬉しさ。目先の楽しみ。', symbol: '•\n••\n•\n•', yesno: 'イエス', fortune: '吉' },
            '1121': { name: 'Puer（少年）', meaning: '男性らしさ、力強さ、未熟さ。未来を切り開く。', symbol: '•\n•\n••\n•', yesno: 'ノー', fortune: '凶。争い事には吉' },
            '2212': { name: 'Albus（白）', meaning: '公正、高潔さ、正義。片思いやプラトニック・ラブ。', symbol: '••\n••\n•\n••', yesno: 'イエス', fortune: '吉' },
            '2122': { name: 'Rubeus（赤）', meaning: '争い事、闘争心。悪いことには吉、良いことには凶。', symbol: '••\n•\n••\n••', yesno: 'ノー', fortune: '凶' },
            '2111': { name: 'Caput Draconis（竜の頭）', meaning: '始まり、新しい扉が開く、前例のない課題に取り組む。やりすぎの傾向。', symbol: '••\n•\n•\n•', yesno: 'イエス', fortune: '吉凶入り混じる。何かを始めるには吉' },
            '1112': { name: 'Cauda Draconis（竜の尾）', meaning: '終わり、物事の完成、途絶。吉は凶となり、凶は吉となる。', symbol: '•\n•\n•\n••', yesno: 'ノー', fortune: '吉でも凶でもない。何かを終わらせるには吉' }
        };

        function showDotOracle() {
            // GA4 イベント送信
            gtag('event', 'oracle_method_selected', {
                'method': 'dot',
                'event_category': 'oracle_interaction',
                'event_label': 'dot_oracle_button'
            });
            
            hideAllScreens();
            document.getElementById('dot-oracle-screen').classList.add('active');
            // スクロール位置を最上部に
            window.scrollTo(0, 0);
            // ボタンを初期状態に戻す
            const generateBtn = document.getElementById('generate-btn');
            generateBtn.textContent = 'シンボルを生成';
            isGenerating = false;
            resetDotOracle();
        }

        function showDiceOracle() {
            // GA4 イベント送信
            gtag('event', 'oracle_method_selected', {
                'method': 'dice',
                'event_category': 'oracle_interaction',
                'event_label': 'dice_oracle_button'
            });
            
            hideAllScreens();
            document.getElementById('dice-oracle-screen').classList.add('active');
            // スクロール位置を最上部に
            window.scrollTo(0, 0);
            // ボタンを初期状態に戻す
            const diceRollBtn = document.getElementById('dice-roll-btn');
            diceRollBtn.textContent = 'ダイスを振る';
            diceRollBtn.disabled = false;
            setTimeout(() => { 
                init3DScene();
                createIdleDice();
            }, 100);
        }

        function showHome() {
            hideAllScreens();
            document.getElementById('home-screen').classList.add('active');
            // スクロール位置を最上部に
            window.scrollTo(0, 0);
        }

        function hideAllScreens() {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => screen.classList.remove('active'));
        }

        function resetDotOracle() {
            zoneDots = [[], [], [], []];
            for (let i = 0; i < 4; i++) {
                const zoneElement = document.getElementById(`zone-${i}`);
                const dots = zoneElement.querySelectorAll('.dot');
                dots.forEach(dot => dot.remove());
                const canvas = document.getElementById(`canvas-${i}`);
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            updateGenerateButton();
        }

        function tapZone(event, zoneIndex) {
            event.preventDefault();
            event.stopPropagation();
            const zoneElement = document.getElementById(`zone-${zoneIndex}`);
            const rect = zoneElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 100;
            const y = ((event.clientY - rect.top) / rect.height) * 100;
            addDot(zoneIndex, x, y);
        }

        function handleTouch(event, zoneIndex) {
            event.preventDefault();
            event.stopPropagation();
            if (event.touches && event.touches.length > 0) {
                const touch = event.touches[0];
                const zoneElement = document.getElementById(`zone-${zoneIndex}`);
                const rect = zoneElement.getBoundingClientRect();
                const x = ((touch.clientX - rect.left) / rect.width) * 100;
                const y = ((touch.clientY - rect.top) / rect.height) * 100;
                addDot(zoneIndex, x, y);
            }
        }

        function addDot(zoneIndex, x, y) {
            if (isGenerating) return;
            if (x < 0 || x > 100 || y < 0 || y > 100) return;
            
            // バッファゾーンでの位置調整
            const bufferSize = 8; // バッファゾーンのサイズ（%）
            let adjustedY = y;
            
            // 上境界近く（各ゾーンの上端）
            if (y < bufferSize && zoneIndex > 0) {
                adjustedY = bufferSize + 2; // 明確に現在のゾーン内に配置
            }
            // 下境界近く（各ゾーンの下端）
            else if (y > (100 - bufferSize) && zoneIndex < 3) {
                adjustedY = 100 - bufferSize - 2; // 明確に現在のゾーン内に配置
            }
            
            zoneDots[zoneIndex].push({ x, y: adjustedY });
            const zoneElement = document.getElementById(`zone-${zoneIndex}`);
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.style.left = `${x}%`;
            dot.style.top = `${adjustedY}%`;
            zoneElement.appendChild(dot);
            const canvas = document.getElementById(`canvas-${zoneIndex}`);
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            updateGenerateButton();
        }

        function updateGenerateButton() {
            if (isGenerating) return;
            const generateBtn = document.getElementById('generate-btn');
            const allZonesHaveDots = zoneDots.every(zone => zone.length > 0);
            if (allZonesHaveDots) {
                generateBtn.classList.add('active');
            } else {
                generateBtn.classList.remove('active');
            }
        }

        function generateSymbol() {
            const generateBtn = document.getElementById('generate-btn');
            if (!generateBtn.classList.contains('active') || isGenerating) return;
            
            // GA4 イベント送信
            gtag('event', 'symbol_generation', {
                'method': 'dot',
                'event_category': 'oracle_interaction',
                'event_label': 'dot_symbol_generated'
            });
            
            document.getElementById('symbol-image').src = '';
            isGenerating = true;
            generateBtn.classList.remove('active');
            generateBtn.textContent = '生成中...';
            for (let i = 0; i < 4; i++) {
                animatePairing(i);
            }
            setTimeout(() => { showSymbolDialog(); }, 2000);
        }

        function showSymbolDialog() {
            const pattern = zoneDots.map(zone => zone.length % 2 === 0 ? '2' : '1').join('');
            let symbol = geomancySymbols[pattern];
            if (!symbol) {
                const keys = Object.keys(geomancySymbols);
                symbol = geomancySymbols[keys[0]];
            }
            
            // GA4 イベント送信 - 結果表示
            gtag('event', 'symbol_result_shown', {
                'symbol_name': symbol.name,
                'symbol_fortune': symbol.fortune,
                'event_category': 'oracle_result',
                'event_label': pattern
            });
            
            // 画像をプリロードしてから表示
            const img = new Image();
            img.onload = () => {
                document.getElementById('symbol-image').src = `${pattern}.png`;
                document.getElementById('symbol-name').textContent = symbol.name;
                document.getElementById('symbol-yesno').textContent = `Yes/No: ${symbol.yesno}`;
                document.getElementById('symbol-fortune').textContent = `吉凶: ${symbol.fortune}`;
                document.getElementById('symbol-meaning').textContent = symbol.meaning;
                
                document.getElementById('symbolDialog').classList.add('show');
            };
            img.src = `${pattern}.png`;
        }

        function closeSymbolDialog() {
            document.getElementById('symbolDialog').classList.remove('show');
            setTimeout(() => {
                const currentScreen = document.querySelector('.screen.active');
                if (currentScreen && currentScreen.id === 'dot-oracle-screen') {
                    resetDotOracle();
                    isGenerating = false;
                    document.getElementById('generate-btn').textContent = 'シンボルを生成';
                } else if (currentScreen && currentScreen.id === 'dice-oracle-screen') {
                    clearDice();
                    createIdleDice();
                    resetDiceResults();
                    // ダイスボタンを元に戻す
                    const diceRollBtn = document.getElementById('dice-roll-btn');
                    diceRollBtn.textContent = 'ダイスを振る';
                    diceRollBtn.disabled = false;
                }
            }, 300);
        }

        function showShieldChartInfo() {
            // GA4 イベント送信
            gtag('event', 'info_viewed', {
                'info_type': 'shield_chart',
                'event_category': 'content_engagement',
                'event_label': 'shield_chart_info_opened'
            });
            
            document.getElementById('shieldChartDialog').classList.add('show');
        }

        function closeShieldChartDialog() {
            document.getElementById('shieldChartDialog').classList.remove('show');
        }

        function toggleSymbolDetails() {
            const content = document.getElementById('symbol-expand-content');
            const arrow = document.getElementById('expand-arrow');
            const text = document.getElementById('expand-text');
            
            if (content.classList.contains('open')) {
                content.classList.remove('open');
                arrow.classList.remove('rotated');
                text.textContent = '保存したい';
            } else {
                // GA4 イベント送信 - 詳細を見る
                gtag('event', 'symbol_details_expanded', {
                    'event_category': 'content_engagement',
                    'event_label': 'symbol_details_opened'
                });
                
                content.classList.add('open');
                arrow.classList.add('rotated');
                text.textContent = '閉じる';
            }
        }

        function scrollToAppSection() {
            // GA4 イベント送信 - アプリセクションへのスクロール
            gtag('event', 'app_section_visited', {
                'event_category': 'app_promotion',
                'event_label': 'scroll_to_app_section'
            });
            
            setTimeout(() => {
                const appSection = document.querySelector('.app-promo-section');
                if (appSection) {
                    appSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 400);
        }

        function resetSymbolExpandSection() {
            const content = document.getElementById('symbol-expand-content');
            const arrow = document.getElementById('expand-arrow');
            const text = document.getElementById('expand-text');
            
            content.classList.remove('open');
            arrow.classList.remove('rotated');
            text.textContent = 'より詳しく';
        }

        function animatePairing(zoneIndex) {
            const zoneElement = document.getElementById(`zone-${zoneIndex}`);
            const canvas = document.getElementById(`canvas-${zoneIndex}`);
            const ctx = canvas.getContext('2d');
            const dots = zoneElement.querySelectorAll('.dot');
            const dotCoords = zoneDots[zoneIndex];
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            for (let i = 0; i < dots.length; i += 2) {
                setTimeout(() => {
                    if (i + 1 < dots.length) {
                        const x1 = (dotCoords[i].x / 100) * canvas.width;
                        const y1 = (dotCoords[i].y / 100) * canvas.height;
                        const x2 = (dotCoords[i + 1].x / 100) * canvas.width;
                        const y2 = (dotCoords[i + 1].y / 100) * canvas.height;
                        ctx.strokeStyle = '#8b7355';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }, i * 100);
            }
        }

        function init3DScene() {
            const container = document.getElementById('dice-3d-container');
            if (!container || !window.THREE || !window.CANNON) return;
            const existingCanvas = container.querySelector('canvas');
            if (existingCanvas) existingCanvas.remove();
            try {
                const width = container.clientWidth;
                const height = container.clientHeight;
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                camera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 1000);
                camera.position.set(0, 20, 0);
                camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.domElement.style.borderRadius = '12px';
                container.appendChild(renderer.domElement);
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(-8, 18, -5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -15;
                directionalLight.shadow.camera.right = 15;
                directionalLight.shadow.camera.top = 15;
                directionalLight.shadow.camera.bottom = -15;
                directionalLight.shadow.radius = 12;
                scene.add(directionalLight);
                world = new CANNON.World();
                world.gravity.set(0, -9, 0);
                world.broadphase = new CANNON.NaiveBroadphase();
                const diceMaterial = new CANNON.Material('dice');
                const floorMaterial = new CANNON.Material('floor');
                const diceDiceContact = new CANNON.ContactMaterial(diceMaterial, diceMaterial, { friction: 0.1, restitution: 1.2 });
                world.addContactMaterial(diceDiceContact);
                const floorDiceContact = new CANNON.ContactMaterial(floorMaterial, diceMaterial, { friction: 0.4, restitution: 0.3 });
                world.addContactMaterial(floorDiceContact);
                createFloor();
                createWalls();
                
                // Three.js Clockを初期化
                clock = new THREE.Clock();
                
                animate3D();
            } catch (error) {
                console.error('3Dシーン初期化エラー:', error);
            }
        }

        function createFloor() {
            const container = document.getElementById('dice-3d-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // コンテナのアスペクト比に基づいて床サイズを計算
            // カメラの視野(-10, 10)に合わせてスケーリング
            const cameraWidth = 20; // -10 to 10
            const cameraHeight = 20; // -10 to 10
            
            // コンテナの実際のサイズに合わせて床サイズを調整
            let floorWidth, floorHeight;
            if (containerWidth > containerHeight) {
                // 横長の場合
                floorHeight = cameraHeight;
                floorWidth = (containerWidth / containerHeight) * cameraHeight;
            } else {
                // 縦長または正方形の場合
                floorWidth = cameraWidth;
                floorHeight = (containerHeight / containerWidth) * cameraWidth;
            }
            
            // 最小・最大サイズの制限
            floorWidth = Math.min(Math.max(floorWidth, 16), 40);
            floorHeight = Math.min(Math.max(floorHeight, 16), 40);
            
            const floorMaterial = new CANNON.Material('floor');
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({ mass: 0, material: floorMaterial });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            floorBody.position.set(0, -6, 0);
            world.add(floorBody);
            const floorGeometry = new THREE.PlaneGeometry(floorWidth, floorHeight);
            const floorMaterialThree = new THREE.MeshLambertMaterial({ color: 0xe8dcc6, transparent: true, opacity: 0.8 });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterialThree);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.y = -6;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);
        }

        function createWalls() {
            const container = document.getElementById('dice-3d-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // 床サイズと全く同じ計算で壁配置を決定
            const cameraWidth = 20;
            const cameraHeight = 20;
            
            let wallDistanceX, wallDistanceZ;
            if (containerWidth > containerHeight) {
                wallDistanceZ = cameraHeight / 2; // 床の端と同じ位置
                wallDistanceX = ((containerWidth / containerHeight) * cameraHeight) / 2;
            } else {
                wallDistanceX = cameraWidth / 2;
                wallDistanceZ = ((containerHeight / containerWidth) * cameraWidth) / 2;
            }
            
            // 床と同じ最小・最大の制限
            const floorWidth = Math.min(Math.max(wallDistanceX * 2, 16), 40);
            const floorHeight = Math.min(Math.max(wallDistanceZ * 2, 16), 40);
            wallDistanceX = floorWidth / 2;
            wallDistanceZ = floorHeight / 2;
            
            const wallHeight = 12;
            const wallPositions = [
                { x: wallDistanceX, y: wallHeight/2 - 6, z: 0, rotY: 0 },
                { x: -wallDistanceX, y: wallHeight/2 - 6, z: 0, rotY: 0 },
                { x: 0, y: wallHeight/2 - 6, z: wallDistanceZ, rotY: Math.PI/2 },
                { x: 0, y: wallHeight/2 - 6, z: -wallDistanceZ, rotY: Math.PI/2 }
            ];
            wallPositions.forEach((pos) => {
                const wallShape = new CANNON.Box(new CANNON.Vec3(0.5, wallHeight/2, Math.max(wallDistanceX, wallDistanceZ)));
                const wallBody = new CANNON.Body({ mass: 0 });
                wallBody.addShape(wallShape);
                wallBody.position.set(pos.x, pos.y, pos.z);
                if (pos.rotY) wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), pos.rotY);
                world.add(wallBody);
                const wallGeometry = new THREE.BoxGeometry(1, wallHeight, Math.max(wallDistanceX, wallDistanceZ) * 2);
                const wallMaterialThree = new THREE.MeshLambertMaterial({ color: 0xd4c4a8, transparent: true, opacity: 0, visible: false });
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterialThree);
                wallMesh.position.set(pos.x, pos.y, pos.z);
                if (pos.rotY) wallMesh.rotation.y = pos.rotY;
                wallMesh.castShadow = false;
                wallMesh.receiveShadow = false;
                scene.add(wallMesh);
            });
        }

        function animate3D() {
            animationId = requestAnimationFrame(animate3D);
            
            if (world && clock) {
                const deltaTime = clock.getDelta();
                const fixedTimeStep = 1/60;
                const maxSubSteps = 3;
                
                // デルタタイムベースの物理演算
                world.step(fixedTimeStep, deltaTime, maxSubSteps);
            }
            
            animateIdleDice();
            diceObjects.forEach((dice) => {
                if (dice.body && dice.mesh && !dice.idleRotation) {
                    dice.mesh.position.copy(dice.body.position);
                    dice.mesh.quaternion.copy(dice.body.quaternion);
                }
            });
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function initDicePhysics() {
            if (!world || !scene) return;
            
            // GA4 イベント送信
            gtag('event', 'dice_roll', {
                'event_category': 'oracle_interaction',
                'event_label': 'dice_rolled'
            });
            
            // 既にダイスが存在する場合は回転力のみ追加
            if (diceObjects.length > 0 && diceObjects.some(dice => dice.body)) {
                diceObjects.forEach(dice => {
                    if (dice.body && !dice.idleRotation) {
                        // 現在の位置を保持したまま新しい回転力を追加（強めに設定）
                        dice.body.angularVelocity.set(
                            (Math.random() - 0.5) * 25,
                            (Math.random() - 0.5) * 25,
                            (Math.random() - 0.5) * 25
                        );
                        // もう少し強く上に持ち上げる
                        dice.body.velocity.set(
                            (Math.random() - 0.5) * 3,
                            4,
                            (Math.random() - 0.5) * 3
                        );
                    }
                });
                resetDiceResults();
                checkDiceSettled();
            } else {
                // 初回の場合は新しくダイスを作成
                clearDice();
                createGeomancyDice();
            }
        }

        function createIdleDice() {
            if (!world || !scene) return;
            clearDice();
            resetDiceResults();
            const elements = ['fire', 'air', 'water', 'earth'];
            const positions = [[-3, 12, -3], [3, 13, -3], [-3, 14, 3], [3, 15, 3]];
            
            for (let i = 0; i < 4; i++) {
                const pos = positions[i];
                const colors = { fire: 0xffcccc, air: 0xffffcc, water: 0xccddff, earth: 0xccffcc };
                const diceGeometry = createRoundedBoxGeometry(3.0, 3.0, 3.0, 0.3, 8);
                const diceMaterialThree = new THREE.MeshLambertMaterial({ color: colors[elements[i]] });
                const diceMesh = new THREE.Mesh(diceGeometry, diceMaterialThree);
                diceMesh.position.set(pos[0], pos[1], pos[2]);
                diceMesh.castShadow = true;
                diceMesh.receiveShadow = true;
                scene.add(diceMesh);
                createDiceDots(diceMesh);
                
                const diceObject = { mesh: diceMesh, id: i, element: elements[i], idleRotation: true };
                diceObjects.push(diceObject);
            }
        }

        function animateIdleDice() {
            diceObjects.forEach((dice) => {
                if (dice.idleRotation && dice.mesh) {
                    dice.mesh.rotation.x += 0.01;
                    dice.mesh.rotation.y += 0.015;
                    dice.mesh.rotation.z += 0.008;
                }
            });
        }

        function createRoundedBoxGeometry(width, height, depth, radius, smoothness) {
            const shape = new THREE.Shape();
            const eps = 0.00001;
            const radius0 = radius - eps;
            shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
            shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
            shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
            shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: depth - radius * 2,
                bevelEnabled: true,
                bevelSegments: smoothness,
                steps: 1,
                bevelSize: radius0,
                bevelThickness: radius,
                curveSegments: smoothness
            });
            geometry.center();
            return geometry;
        }

        function createGeomancyDice() {
            clearDice();
            resetDiceResults();
            const elements = ['fire', 'air', 'water', 'earth'];
            for (let i = 0; i < 4; i++) {
                const dice = createSingleDice(i, elements[i]);
                diceObjects.push(dice);
            }
            checkDiceSettled();
        }

        function createSingleDice(index, element) {
            const positions = [[-3, 12, -3], [3, 13, -3], [-3, 14, 3], [3, 15, 3]];
            const pos = positions[index];
            const diceShape = new CANNON.Box(new CANNON.Vec3(1.5, 1.5, 1.5));
            const diceMaterial = new CANNON.Material('dice');
            const diceBody = new CANNON.Body({ mass: 1, material: diceMaterial, linearDamping: 0.1, angularDamping: 0.1 });
            diceBody.addShape(diceShape);
            diceBody.position.set(pos[0], pos[1], pos[2]);
            diceBody.angularVelocity.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
            world.add(diceBody);
            const colors = { fire: 0xffcccc, air: 0xffffcc, water: 0xccddff, earth: 0xccffcc };
            const diceGeometry = createRoundedBoxGeometry(3.0, 3.0, 3.0, 0.3, 8);
            const diceMaterialThree = new THREE.MeshLambertMaterial({ color: colors[element] });
            const diceMesh = new THREE.Mesh(diceGeometry, diceMaterialThree);
            diceMesh.castShadow = true;
            diceMesh.receiveShadow = true;
            scene.add(diceMesh);
            createDiceDots(diceMesh);
            const diceObject = { body: diceBody, mesh: diceMesh, id: index, element: element, idleRotation: false };
            return diceObject;
        }

        function createDiceDots(diceMesh) {
            const dotGeometry = new THREE.CircleGeometry(0.24, 16);
            const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const faceValues = [1, 2, 1, 2, 1, 2];
            diceMesh.userData.faceValues = faceValues;
            const faces = [
                { normal: [1, 0, 0], center: [1.51, 0, 0], rotation: [0, Math.PI/2, 0], index: 0 },
                { normal: [-1, 0, 0], center: [-1.51, 0, 0], rotation: [0, -Math.PI/2, 0], index: 1 },
                { normal: [0, 1, 0], center: [0, 1.51, 0], rotation: [-Math.PI/2, 0, 0], index: 2 },
                { normal: [0, -1, 0], center: [0, -1.51, 0], rotation: [Math.PI/2, 0, 0], index: 3 },
                { normal: [0, 0, 1], center: [0, 0, 1.51], rotation: [0, 0, 0], index: 4 },
                { normal: [0, 0, -1], center: [0, 0, -1.51], rotation: [0, Math.PI, 0], index: 5 }
            ];
            faces.forEach((face) => {
                const dotCount = faceValues[face.index];
                if (dotCount === 1) {
                    const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                    dot.position.set(face.center[0], face.center[1], face.center[2]);
                    dot.rotation.set(face.rotation[0], face.rotation[1], face.rotation[2]);
                    diceMesh.add(dot);
                } else {
                    const positions = [[face.center[0] - 0.6, face.center[1] - 0.6, face.center[2]], [face.center[0] + 0.6, face.center[1] + 0.6, face.center[2]]];
                    if (face.normal[0] !== 0) {
                        positions[0] = [face.center[0], face.center[1] - 0.6, face.center[2] - 0.6];
                        positions[1] = [face.center[0], face.center[1] + 0.6, face.center[2] + 0.6];
                    } else if (face.normal[1] !== 0) {
                        positions[0] = [face.center[0] - 0.6, face.center[1], face.center[2] - 0.6];
                        positions[1] = [face.center[0] + 0.6, face.center[1], face.center[2] + 0.6];
                    }
                    positions.forEach(pos => {
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        dot.position.set(pos[0], pos[1], pos[2]);
                        dot.rotation.set(face.rotation[0], face.rotation[1], face.rotation[2]);
                        diceMesh.add(dot);
                    });
                }
            });
        }

        function clearDice() {
            diceObjects.forEach(dice => {
                if (dice.body) world.remove(dice.body);
                if (dice.mesh) scene.remove(dice.mesh);
            });
            diceObjects = [];
            diceResults = [];
        }

        function resetDiceResults() {
            for (let i = 0; i < 4; i++) {
                const resultElement = document.getElementById(`dice-result-${i}`);
                resultElement.textContent = '?';
                resultElement.classList.add('empty');
            }
        }

        function updateDiceResult(index, value) {
            const resultElement = document.getElementById(`dice-result-${index}`);
            resultElement.textContent = value;
            resultElement.classList.remove('empty');
        }

        function checkDiceSettled() {
            const checkInterval = setInterval(() => {
                let allSettled = true;
                diceObjects.forEach(dice => {
                    const velocity = dice.body.velocity.length();
                    const angularVelocity = dice.body.angularVelocity.length();
                    if (velocity > 0.01 || angularVelocity > 0.01) allSettled = false;
                });
                if (allSettled) {
                    clearInterval(checkInterval);
                    setTimeout(() => { calculateDiceResults(); }, 500);
                }
            }, 100);
        }

        function calculateDiceResults() {
            diceResults = [];
            // ボタンを「生成中...」に変更して無効化
            const diceRollBtn = document.getElementById('dice-roll-btn');
            diceRollBtn.textContent = '生成中...';
            diceRollBtn.disabled = true;
            
            diceObjects.forEach((dice, index) => {
                const upVector = new THREE.Vector3(0, 1, 0);
                const faceNormals = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(-1, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(0, -1, 0),
                    new THREE.Vector3(0, 0, 1),
                    new THREE.Vector3(0, 0, -1)
                ];
                let maxDot = -1;
                let topFaceIndex = 0;
                faceNormals.forEach((faceNormal, faceIndex) => {
                    const rotatedNormal = faceNormal.clone();
                    rotatedNormal.applyQuaternion(dice.mesh.quaternion);
                    const dot = upVector.dot(rotatedNormal);
                    if (dot > maxDot) {
                        maxDot = dot;
                        topFaceIndex = faceIndex;
                    }
                });
                const result = dice.mesh.userData.faceValues[topFaceIndex];
                diceResults.push(result);
                updateDiceResult(index, result);
            });
            setTimeout(() => { generateSymbolFromDice(); }, 1500);
        }

        function generateSymbolFromDice() {
            if (diceResults.length !== 4) return;
            const pattern = diceResults.join('');
            let symbol = geomancySymbols[pattern];
            if (!symbol) {
                const keys = Object.keys(geomancySymbols);
                symbol = geomancySymbols[keys[0]];
            }
            
            // GA4 イベント送信
            gtag('event', 'symbol_generation', {
                'method': 'dice',
                'event_category': 'oracle_interaction',
                'event_label': 'dice_symbol_generated'
            });
            
            gtag('event', 'symbol_result_shown', {
                'symbol_name': symbol.name,
                'symbol_fortune': symbol.fortune,
                'event_category': 'oracle_result',
                'event_label': pattern,
                'method': 'dice'
            });
            
            // 画像をプリロードしてから表示
            const img = new Image();
            img.onload = () => {
                document.getElementById('symbol-image').src = `${pattern}.png`;
                document.getElementById('symbol-name').textContent = symbol.name;
                document.getElementById('symbol-yesno').textContent = `Yes/No: ${symbol.yesno}`;
                document.getElementById('symbol-fortune').textContent = `吉凶: ${symbol.fortune}`;
                document.getElementById('symbol-meaning').textContent = symbol.meaning;
                
                document.getElementById('symbolDialog').classList.add('show');
            };
            img.src = `${pattern}.png`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            // スクロール復元を無効化してスクロール位置を制御
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            // 初期表示時も最上部に
            window.scrollTo(0, 0);
            
            // Service Worker登録
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js')
                        .then(registration => {
                            console.log('ServiceWorker registered:', registration);
                        })
                        .catch(err => {
                            console.log('ServiceWorker registration failed:', err);
                        });
                });
            }
            
            // Service Worker更新チェック
            checkForServiceWorkerUpdate();
            
            // 定期的な更新チェック（5分毎）
            setInterval(checkForServiceWorkerUpdate, 5 * 60 * 1000);
            
            // ページがアクティブになった時の更新チェック
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // ページがアクティブになった時にチェック
                    checkForServiceWorkerUpdate();
                }
            });
            
            // ウィンドウがフォーカスされた時の更新チェック
            window.addEventListener('focus', () => {
                checkForServiceWorkerUpdate();
            });
        });

        document.addEventListener('touchstart', function() {}, {passive: true});

        // Service Worker更新関連の関数
        function checkForServiceWorkerUpdate() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration()
                    .then(registration => {
                        if (registration) {
                            registration.update();
                            
                            registration.addEventListener('updatefound', () => {
                                const newWorker = registration.installing;
                                newWorker.addEventListener('statechange', () => {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        updateAvailable = true;
                                        showUpdateBanner();
                                        
                                        // GA4 イベント送信
                                        gtag('event', 'app_update_available', {
                                            'event_category': 'app_lifecycle',
                                            'event_label': 'update_detected'
                                        });
                                    }
                                });
                            });
                        }
                    })
                    .catch(error => {
                        console.log('Service Worker registration check failed:', error);
                    });
            }
        }

        function showUpdateBanner() {
            const banner = document.getElementById('updateBanner');
            if (banner && !banner.classList.contains('show')) {
                banner.classList.add('show');
                
                // 自動非表示を削除 - ユーザーが手動で閉じるまで表示し続ける
            }
        }

        function hideUpdateBanner() {
            const banner = document.getElementById('updateBanner');
            if (banner) {
                banner.classList.remove('show');
            }
        }

        function updateApp() {
            if (updateAvailable) {
                // GA4 イベント送信
                gtag('event', 'app_update_clicked', {
                    'event_category': 'app_lifecycle',
                    'event_label': 'manual_update'
                });
                
                hideUpdateBanner();
                
                // Service Worker更新処理
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.getRegistration()
                        .then(registration => {
                            if (registration && registration.waiting) {
                                // 新しいService Workerに切り替え
                                registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                                
                                // 古いキャッシュを完全削除してからリロード
                                caches.keys().then(cacheNames => {
                                    return Promise.all(
                                        cacheNames.map(cacheName => {
                                            console.log('Deleting cache:', cacheName);
                                            return caches.delete(cacheName);
                                        })
                                    );
                                }).then(() => {
                                    console.log('All caches cleared, reloading...');
                                    // 強制リロード
                                    window.location.href = window.location.href;
                                });
                            } else {
                                // waiting worker がない場合は通常リロード
                                window.location.reload();
                            }
                        });
                } else {
                    // Service Worker非対応の場合は単純にリロード
                    window.location.reload();
                }
            }
        }

        // Service Workerからのメッセージを受信
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data && event.data.type === 'SW_UPDATED') {
                    // Service Workerが更新された時の処理
                    window.location.reload();
                }
            });
        }
    </script>
</body>
</html>
